# Claude Code Project Guidelines

## Project Philosophy

### Code Simplicity
- **Keep it simple**: Prioritize readable, maintainable code over clever solutions
- **No premature optimization**: Build features that work, optimize later if needed
- **Minimal dependencies**: Only add libraries when truly necessary
- **Clear naming**: Variable and function names should be self-documenting

### Modularity
- **Single responsibility**: Each module/class should do one thing well
- **Loose coupling**: Modules should work independently
- **Easy to test**: Code structure should facilitate unit testing
- **Clear interfaces**: Well-defined inputs and outputs

### Development Approach
- **Incremental**: Build feature by feature, test as you go
- **Sprint-based**: Follow the 5-week sprint plan
- **Test-driven when possible**: Write tests for critical functionality
- **Document as you build**: Keep docs in sync with code

## Code Style

### Python
- Follow PEP 8 guidelines
- Use type hints where helpful (but not obsessively)
- Maximum line length: 100 characters
- Docstrings for all public functions/classes
- Prefer explicit over implicit

### Structure
```
Keep the modular structure:
- src/lepsox/agents/     # One agent per file or grouped by type
- src/lepsox/models/     # Data models
- src/lepsox/integrations/  # External APIs
- tests/                 # Mirror src structure
```

## Sprint Goals

### Sprint 1: Foundation
- Get all 16 validators working
- Basic file I/O (read Excel, write results)
- Test with sample data
- **Keep it simple**: No web UI yet, just CLI

### Sprint 2: iNaturalist Integration
- Connect validators to iNat API
- Species/location verification
- Record detection
- **Keep it simple**: Direct API calls, basic caching

### Sprint 3: Web Interface (Optional)
- Only if Sprint 1-2 are solid
- Basic FastAPI endpoints
- Simple frontend
- **Keep it simple**: Start with upload/download only

### Future Sprints
- Add features based on actual usage
- Don't build what isn't needed
- Get feedback from real users first

## What NOT to Do

❌ **Don't over-engineer**
- No complex design patterns unless clearly needed
- No abstract base classes with one implementation
- No framework when a simple function will do

❌ **Don't add unused features**
- No "just in case" code
- No speculative generalization
- No features not in the current sprint

❌ **Don't sacrifice readability**
- No one-liners that require mental parsing
- No deeply nested logic
- No magic numbers or strings

## What TO Do

✅ **Keep it readable**
- Code that a junior developer can understand
- Comments for "why", not "what"
- Break complex logic into named functions

✅ **Make it testable**
- Small, focused functions
- Dependency injection where it helps testing
- Test fixtures for common scenarios

✅ **Follow the plan**
- Complete Sprint 1 before adding Sprint 2 features
- Get feedback before building more
- Iterate based on real usage

## Remember

> "Perfection is achieved, not when there is nothing more to add,
> but when there is nothing left to take away."
> - Antoine de Saint-Exupéry

Build what's needed. No more, no less.
